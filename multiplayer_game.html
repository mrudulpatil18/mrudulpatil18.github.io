<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Mrudul | Home</title>
    <link rel="stylesheet" href="static/tufte.css" />
    <link rel="stylesheet" href="static/override.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="static/prism.css" rel="stylesheet" />
</head>

<body>

<header>
    <nav class="group">
        <ul>
            <li><a href="/about" class="">Home</a></li>
            <li><a href="/posts" class="active">Posts</a></li>
        </ul>
    </nav>
</header>
<article>
    <section><h1>Building a Multiplayer Maze Game</h1><p>I have always been a little curious on how socket programming works. I had only worked with HTTP based connections till this point. I was intrigued by how low latency games handle communcation. Thats when i read about sockets. Many attempts to understand how they work and how to use websockets went in vain as i got intimated.</p><h2>Background</h2><p>That's when i decided, I am going to make a multiplayer game based on sockets. Now this is a time, when i had become too dependent on LLMs and ChatGPT for writing code or solving problems.</p><p>So i set a few rules for myself. </p><ul><li> No using ChatGpt or LLM generators, can use good old google search for help</li><li> Using minimal libraries, try to write from fundamentals.</li></ul><h3>The Concept</h3><p>With a bit of thought and brainstorming, I came up with a game loop.It had to involve multiplayer, competitiveness and Mazes. Mazes would involve going from a start position to end position in a <em>mazelike</em> environment, with multiple misleading paths at regular intervals.I couldn't visualise how multiple players ( lets keep it at 2 players for simplicity. ) can compete and have fun trying to solve the same maze together.</p><p>So, I decided, both players would start with mazes (randomly generated) of a fixed size (say 5 ). It would be a race to finish a fixed number of mazes. When a player completes a maze, a maze grid of higher dimension is generated. The first person to finish the final maze (say 10) <strong>wins</strong>.</p><p>To keep the multiplayer feel alive, i added a twist. Everytime a player finishes a maze and a new bigger maze is generated, the maze of the opponent player resets. Now this should add a multiplayer feel. Now its not just a a race to the end, but also involves sabotaging the opponent on each completion.</p><h3>Tech Stack</h3><p>My proffesional work involved working with Java and Spring Boot. So i went ahead with Java for the server side logic implentation to handle multiplayer logic and maze generation. For the visual part of the game, i decided to go with browser based game for easy access. My self-established rules obliged me to use HTML, CSS and JS-Canvas to implement the UI.</p><h2>Implementation</h2><h3>Maze Generation</h3><p>There are multiple maze generation algorithms available on the internet. They have their own biases. Hunt-and-Kill algorithm was decided to keep bais minimal with our context and generate visually asthetic mazes.</p><p>Algorithm:</p><p>Choose a random point in the grid as the start cell.</p><ul><li> Walk Phase:  From the start cell, random neighour is chosen as next cell and this process repeats until a cell is reached with no unvisited neighbours.</li><li> Hunt Phase:  Choose a cell in the grid with atleast one unvisited neighbour. Connect the cell and an univited neighbour to this cell.</li></ul><p>The walk phase repeats from the chosen cell from hunt cell. This process is repeated until, no more univisted cells are found in hunt phase.</p><p>In current implementation, the longest path from the start point in the maze is searched to decide the finish cell in the maze.</p><p>Code:</p><pre><code>Maze generateMaze(int width, int height, Coordinate startCoordinate) {<br>        Coordinate currentCell = startCoordinate;<br>        Set&lt;Coordinate&gt; visited = new HashSet&lt;&gt;();<br>        Set&lt;Coordinate&gt; nonVisited = initializeNonVisited(width, height);<br>        Maze maze = new Maze(width, height);<br><br>        <br>        *if*(startCoordinate == null){<br>            currentCell = getRandomCell(width, height);<br>        }<br><br>        // Start from random cell<br>        maze.setStart(currentCell);<br>        visited.add(currentCell);<br>        nonVisited.remove(currentCell);<br><br>        while (!nonVisited.isEmpty()) {<br>            // Walk phase - keep walking until no unvisited neighbors<br>            while (true) {<br>                List&lt;Coordinate&gt; unvisitedNeighbors = getUnvisitedNeighbors(maze, currentCell, visited);<br>                if (unvisitedNeighbors.isEmpty()) {<br>                    break;<br>                }<br>                <br>                Coordinate nextCell = getRandomElement(unvisitedNeighbors);<br>                maze.carveEdge(currentCell, nextCell);<br>                visited.add(nextCell);<br>                nonVisited.remove(nextCell);<br>                currentCell = nextCell;<br>            }<br><br>            // Hunt phase - find an unvisited cell with at least one visited neighbor<br>            Coordinate huntResult = hunt(maze, nonVisited, visited);<br>            if (huntResult == null) {<br>                break; // No valid cells found during hunt - maze is complete<br>            }<br>            <br>            // Connect the hunted cell to a random visited neighbor<br><br>            List&lt;Coordinate&gt; visitedNeighbors = getVisitedNeighbors(maze, huntResult, visited);<br>            Coordinate connectTo = getRandomElement(visitedNeighbors);<br>            maze.carveEdge(huntResult, connectTo);<br>            <br>            visited.add(huntResult);<br>            nonVisited.remove(huntResult);<br>            currentCell = huntResult;<br>        }<br>        maze.setEnd(getFarthestCellCoordinates(maze, width, height));<br>        return maze;<br>    }<br></code></pre><p>Great, we can now generate mazes on any size. Lets look at the aim of the project, to tackle socket communications.</p><h3>Sockets</h3><p>I decided to utlize WebSockets made available by spring framework.</p><p>We need to setup configuration bean with <code>@EnableWebSocket</code> which implements <code>WebSocketConfigurer</code> interface. This interface helps register webSocketHandlers with required path mapping.</p><p>Code:</p><pre><code>@Configuration<br>@EnableWebSocket<br>public class WebSocketConfig implements WebSocketConfigurer {<br><br>    // inject WebSocketHandler bean<br><br>    @Override<br>    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {<br>        registry.addHandler(webSocketHandler, "/websocket").setAllowedOrigins("*");<br>    }<br>}<br></code></pre><p>We also need to setup a <code>WebSocketHandler</code> spring bean using <code>WebSocketHandler</code> Interface.</p><p>Methods provided by interface</p><ul><li> <code>afterConnectionEstablished(WebSocketSession session)</code>: This method is called after a new WebSocket session has been established.</li><li> <code>handleTextMessage(WebSocketSession session, TextMessage message)</code>: This method handles incoming text messages.</li><li> <code>handleBinaryMessage(WebSocketSession session, BinaryMessage message)</code>: This method handles binary messages.( NOT Required as we'll be using text based communication )</li><li> <code>afterConnectionClosed(WebSocketSession session, CloseStatus status)</code>: This method is invoked after a WebSocket session has been closed.</li></ul><p>I wanted to implement a room creation and joining logic like how popular web-based multiplayer games like SmashKarts, AmongUs and Scribble handle it. To achieve that, we create rooms with uuid based unique 5 digit codes and assign socket conenctions to the room.</p><ul><li> On CREATE Room -&gt; a new room is created and the player's socket connection is added to the room as first player using <code>afterConnectionEstablished</code> and a unique room code is returned.</li><li> On JOIN Room -&gt; the room is joined based on code entered and socket connection is added to the room as second player using <code>afterConnectionEstablished</code></li></ul><p><code>handleTextMessage</code> is utilised to communicate states between frontend and this server. Changes like player moves are sent and are verified by backend, and on completion of mazes or game start, generated mazes are communicated back to frontend by serializing and deserialing to JSON.</p><p>When a player leaves the lobby / room, <code>afterConnectionClosed</code> closes the opponents socket connection and deletes the room from memory.</p><p><em>for a detailed view at implementation , take take a look at the source code at <a href="link">github</a></em></p><h3>Visuals</h3><p>I established a game loop with typescript using canvas,Initially , I had planned to make a simple 2d maze, and this is what i had achieved.</p><p>&lt; img &gt;</p><p>I was pretty happy with what i had, but i wannted to implement 3D somehow to the game,to make it more alive and asthetic. While scrolling through google images for inspiration, i saw an isometric view maze and it caught my attention. Visualising paths in isometric would add another dimension to my game, while making it look good at the same time.</p><p>I went in a rabit hole to understand the maths behind isometric games and how i would use it. I made a isometric based ( 3d-like ) visuals to the maze by creating isometric 3d blocks and laying them up in the maze form.</p><p>I did have a challenge in the process though...  My grids were thin walled. what that means is, in a grid representation, i used to represent only the cells which are walkable. for isometric view i had to convert my thin wallled mazes to thick walled (walls are made up of blocks ). I faced a dilemma, should i conevert my backend to work with, generate and understand thick walled mazes or do i keep in the frontend only for visualisation. But it changed things as moves made by player in thick walled maze would mean different thing in thin walled as it is effectively twice the grid size.</p><p>I decided to create a layer in the frontend to conevert coordinates from thick walled to thin walled version before communicating with backend. I faced a bunch of wacky bugs and issues in this process, but finally got it working.</p><figure><img src="link" alt="img"/></figure><p>Everthing works now, i was still not satisfied, it feels competitive, it works and it looks 3d and good. I wanted to wrap it up in some sort of cool fantasy game. I was deep in unfamiliar waters, never having worked with canvas or sockets or isometric games for that matter..</p><p>Scrolling through isometric games for inspiration i really liked how some games decorating it visually with help of assests and tiles and creatively using isometric layers. On scouring the internet i found these beautiful isometric (assests)[link].</p><p>To use it , had to change a ton of implementation to utilize tiles insted of cubes to create a maze and the surroudning environment, the start cell was a MAGE / WIZARD now , and the goal was to reach the tower.</p><p>Another tough challenge in this process was to keep the map in the center of screen and make sure all of the maze is visible at a time. After a lot of failing and maths, i ended up with a decent camera implementation to deal with it. I did plan to allow zooming in and out and moving around the tilemap with a mouse, but discarded it later.</p><p>I also added a bit of animations for fun. ( PS. they are still buggy )</p><p>Here's how it looks now:</p><figure><img src="link" alt="img"/></figure><h3>Lore</h3><p>With all the cool game-like visuals, its absolutely essential (in my eyes ) for the game to have a cool lore.</p><p>Introducing <strong>MoonRift</strong></p><blockquote><p>The universe is collapsing. Only one world can survive, powered by ancient Moon Towers linked to a dying moon.</p><p>Two rival Moon Mages race through shifting mazes to reach their towers. Each time one powers up, the other weakens.</p><p>First to Level 10 saves their world. The other is lost to darkness.</p></blockquote><h3>Learning</h3><p>Lots of cleaning up and bug fixes later. I deployed the project. I learnt lot many things through the adventure. From sockets, to canvas to communication protocols etc. But the truth is I got tired towards the end. Why ? Writing the UI. Working on the visual part of the game was much much more and time consuming than the multiplayer backend, which was intented goal anyways.</p><p>To be clear, it was still absolutely worth it and lots of fun.</p><p>The current state of game is - <em>playable</em>. Lots of improvements are required to make it polished. But i am done with it for now. I would  love to visit it later and improve it. If you as viewer want to add or fix somthing, feel free to fork and contribute to the project however you want.</p><p>I did not go into too much detail about most of the technical implementation for this post. Also most of the developement of backend and ui happened parallely, i have made it seem linear for simplicity of understanding. Lots and lots of work went into the coding the game from strach in canvas without any libraries or past experience.</p><p>I hope you had fun reading this and get inspired from my rookie-self.</p><p>Cheers,Mrudul</p><h1>placeholder title</h1><p>I have always been a little curious on how socket programming works. I had only worked with HTTP based connections till this point. I was intrigued by how low latency games handle communcation. Thats when i read about sockets. Many attempts to understand how they work and how to use websockets went in vain as i got intimated.</p><h2>Background</h2><p>That's when i decided, I am going to make a multiplayer game based on sockets. Now this is a time, when i had become too dependent on LLMs and ChatGPT for writing code or solving problems.</p><p>So i set a few rules for myself.1. No using ChatGpt or LLM generators, can use good old google search for help2. Using minimal libraries, try to write from fundamentals.</p><h3>The Concept</h3><p>With a bit of thought and brainstorming, I came up with a game loop.It had to involve multiplayer, competitiveness and Mazes. Mazes would involve going from a start position to end position in a <em>mazelike</em> environment, with multiple misleading paths at regular intervals.I couldn't visualise how multiple players ( lets keep it at 2 players for simplicity. ) can compete and have fun trying to solve the same maze together.</p><p>So, I decided, both players would start with mazes (randomly generated) of a fixed size (say 5 ). It would be a race to finish a fixed number of mazes. When a player completes a maze, a maze grid of higher dimension is generated. The first person to finish the final maze (say 10) <strong>wins</strong>.</p><p>To keep the multiplayer feel alive, i added a twist. Everytime a player finishes a maze and a new bigger maze is generated, the maze of the opponent player resets. Now this should add a multiplayer feel. Now its not just a a race to the end, but also involves sabotaging the opponent on each completion.</p><h3>Tech Stack</h3><p>My proffesional work involved working with Java and Spring Boot. So i went ahead with Java for the server side logic implentation to handle multiplayer logic and maze generation. For the visual part of the game, i decided to go with browser based game for easy access. My self-established rules obliged me to use HTML, CSS and JS-Canvas to implement the UI.</p><h2>Implementation</h2><h3>Maze Generation</h3><p>There are multiple maze generation algorithms available on the internet. They have their own biases. Hunt-and-Kill algorithm was decided to keep bais minimal with our context and generate visually asthetic mazes.</p><p>Algorithm:</p><p>Choose a random point in the grid as the start cell.</p><ul><li> Walk Phase:  From the start cell, random neighour is chosen as next cell and this process repeats until a cell is reached with no unvisited neighbours.</li><li> Hunt Phase:  Choose a cell in the grid with atleast one unvisited neighbour. Connect the cell and an univited neighbour to this cell.</li></ul><p>The walk phase repeats from the chosen cell from hunt cell. This process is repeated until, no more univisted cells are found in hunt phase.</p><p>In current implementation, the longest path from the start point in the maze is searched to decide the finish cell in the maze.</p><p>Code:</p><pre><code>Maze generateMaze(int width, int height, Coordinate startCoordinate) {<br>        Coordinate currentCell = startCoordinate;<br>        Set&lt;Coordinate&gt; visited = new HashSet&lt;&gt;();<br>        Set&lt;Coordinate&gt; nonVisited = initializeNonVisited(width, height);<br>        Maze maze = new Maze(width, height);<br><br>        <br>        if(startCoordinate == null){<br>            currentCell = getRandomCell(width, height);<br>        }<br><br>        // Start from random cell<br>        maze.setStart(currentCell);<br>        visited.add(currentCell);<br>        nonVisited.remove(currentCell);<br><br>        while (!nonVisited.isEmpty()) {<br>            // Walk phase - keep walking until no unvisited neighbors<br>            while (true) {<br>                List&lt;Coordinate&gt; unvisitedNeighbors = getUnvisitedNeighbors(maze, currentCell, visited);<br>                if (unvisitedNeighbors.isEmpty()) {<br>                    break;<br>                }<br>                <br>                Coordinate nextCell = getRandomElement(unvisitedNeighbors);<br>                maze.carveEdge(currentCell, nextCell);<br>                visited.add(nextCell);<br>                nonVisited.remove(nextCell);<br>                currentCell = nextCell;<br>            }<br><br>            // Hunt phase - find an unvisited cell with at least one visited neighbor<br>            Coordinate huntResult = hunt(maze, nonVisited, visited);<br>            if (huntResult == null) {<br>                break; // No valid cells found during hunt - maze is complete<br>            }<br>            <br>            // Connect the hunted cell to a random visited neighbor<br><br>            List&lt;Coordinate&gt; visitedNeighbors = getVisitedNeighbors(maze, huntResult, visited);<br>            Coordinate connectTo = getRandomElement(visitedNeighbors);<br>            maze.carveEdge(huntResult, connectTo);<br>            <br>            visited.add(huntResult);<br>            nonVisited.remove(huntResult);<br>            currentCell = huntResult;<br>        }<br>        maze.setEnd(getFarthestCellCoordinates(maze, width, height));<br>        return maze;<br>    }<br></code></pre><p>Great, we can now generate mazes on any size. Lets look at the aim of the project, to tackle socket communications.</p><h3>Sockets</h3><p>I decided to utlize WebSockets made available by spring framework.</p><p>We need to setup configuration bean with <code>@EnableWebSocket</code> which implements <code>WebSocketConfigurer</code> interface. This interface helps register webSocketHandlers with required path mapping.</p><p>Code:</p><pre><code>@Configuration<br>@EnableWebSocket<br>public class WebSocketConfig implements WebSocketConfigurer {<br><br>    // inject WebSocketHandler bean<br><br>    @Override<br>    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {<br>        registry.addHandler(webSocketHandler, "/websocket").setAllowedOrigins("*");<br>    }<br>}<br></code></pre><p>We also need to setup a <code>WebSocketHandler</code> spring bean using <code>WebSocketHandler</code> Interface.</p><p>Methods provided by interface</p><ul><li> <code>afterConnectionEstablished(WebSocketSession session)</code>: This method is called after a new WebSocket session has been established.</li><li> <code>handleTextMessage(WebSocketSession session, TextMessage message)</code>: This method handles incoming text messages.</li><li> <code>handleBinaryMessage(WebSocketSession session, BinaryMessage message)</code>: This method handles binary messages.( NOT Required as we'll be using text based communication )</li><li> <code>afterConnectionClosed(WebSocketSession session, CloseStatus status)</code>: This method is invoked after a WebSocket session has been closed.</li></ul><p>I wanted to implement a room creation and joining logic like how popular web-based multiplayer games like SmashKarts, AmongUs and Scribble handle it. To achieve that, we create rooms with uuid based unique 5 digit codes and assign socket conenctions to the room.</p><ul><li> On CREATE Room -&gt; a new room is created and the player's socket connection is added to the room as first player using <code>afterConnectionEstablished</code> and a unique room code is returned.</li><li> On JOIN Room -&gt; the room is joined based on code entered and socket connection is added to the room as second player using <code>afterConnectionEstablished</code></li></ul><p><code>handleTextMessage</code> is utilised to communicate states between frontend and this server. Changes like player moves are sent and are verified by backend, and on completion of mazes or game start, generated mazes are communicated back to frontend by serializing and deserialing to JSON.</p><p>When a player leaves the lobby / room, <code>afterConnectionClosed</code> closes the opponents socket connection and deletes the room from memory.</p><p><em>for a detailed view at implementation , take take a look at the source code at <a href="link">github</a></em></p><h3>Visuals</h3><p>I established a game loop with typescript using canvas,Initially , I had planned to make a simple 2d maze, and this is what i had achieved.</p><p>&lt; img &gt;</p><p>I was pretty happy with what i had, but i wannted to implement 3D somehow to the game,to make it more alive and asthetic. While scrolling through google images for inspiration, i saw an isometric view maze and it caught my attention. Visualising paths in isometric would add another dimension to my game, while making it look good at the same time.</p><p>I went in a rabit hole to understand the maths behind isometric games and how i would use it. I made a isometric based ( 3d-like ) visuals to the maze by creating isometric 3d blocks and laying them up in the maze form.</p><p>I did have a challenge in the process though...  My grids were thin walled. what that means is, in a grid representation, i used to represent only the cells which are walkable. for isometric view i had to convert my thin wallled mazes to thick walled (walls are made up of blocks ). I faced a dilemma, should i conevert my backend to work with, generate and understand thick walled mazes or do i keep in the frontend only for visualisation. But it changed things as moves made by player in thick walled maze would mean different thing in thin walled as it is effectively twice the grid size.</p><p>I decided to create a layer in the frontend to conevert coordinates from thick walled to thin walled version before communicating with backend. I faced a bunch of wacky bugs and issues in this process, but finally got it working.</p><figure><img src="link" alt="img"/></figure><p>Everthing works now, i was still not satisfied, it feels competitive, it works and it looks 3d and good. I wanted to wrap it up in some sort of cool fantasy game. I was deep in unfamiliar waters, never having worked with canvas or sockets or isometric games for that matter..</p><p>Scrolling through isometric games for inspiration i really liked how some games decorating it visually with help of assests and tiles and creatively using isometric layers. On scouring the internet i found these beautiful isometric (assests)[link].</p><p>To use it , had to change a ton of implementation to utilize tiles insted of cubes to create a maze and the surroudning environment, the start cell was a MAGE / WIZARD now , and the goal was to reach the tower.</p><p>Another tough challenge in this process was to keep the map in the center of screen and make sure all of the maze is visible at a time. After a lot of failing and maths, i ended up with a decent camera implementation to deal with it. I did plan to allow zooming in and out and moving around the tilemap with a mouse, but discarded it later.</p><p>I also added a bit of animations for fun. ( PS. they are still buggy )</p><p>Here's how it looks now:</p><figure><img src="link" alt="img"/></figure><h3>Lore</h3><p>With all the cool game-like visuals, its absolutely essential (in my eyes ) for the game to have a cool lore.</p><p>Introducing <strong>MoonRift</strong></p><blockquote><p>The universe is collapsing. Only one world can survive, powered by ancient Moon Towers linked to a dying moon.</p><p>Two rival Moon Mages race through shifting mazes to reach their towers. Each time one powers up, the other weakens.</p><p>First to Level 10 saves their world. The other is lost to darkness.</p></blockquote><h3>Learning</h3><p>Lots of cleaning up and bug fixes later. I deployed the project. I learnt lot many things through the adventure. From sockets, to canvas to communication protocols etc. But the truth is I got tired towards the end. Why ? Writing the UI. Working on the visual part of the game was much much more and time consuming than the multiplayer backend, which was intented goal anyways.</p><p>To be clear, it was still absolutely worth it and lots of fun.</p><p>The current state of game is - <em>playable</em>. Lots of improvements are required to make it polished. But i am done with it for now. I would  love to visit it later and improve it. If you as viewer want to add or fix somthing, feel free to fork and contribute to the project however you want.</p><p>I did not go into too much detail about most of the technical implementation for this post. Also most of the developement of backend and ui happened parallely, i have made it seem linear for simplicity of understanding. Lots and lots of work went into the coding the game from strach in canvas without any libraries or past experience.</p><p>I hope you had fun reading this and get inspired from my rookie-self.</p><p>Cheers,Mrudul</p></section>
    <section>
        <hr>
        <p>Thanks for stopping by! Feel free to reach out.</p>
        <p class="social">
            <a href="https://github.com/yourusername"><img src="static/github.svg" alt="Github Logo"></a>
            <a href="https://linkedin.com/in/yourusername"><img src="static/linkedin.svg" alt="Linkedin Logo"></a>
            <a href="mailto:your-email@gmail.com"><img src="static/mail.svg" alt="Mail Logo" ></a>
        </p>
    </section>

</article>
<footer>
    <span class="credits">© 2025
      Mrudul Patil
    </span>
    </div>
</footer>

<script src="https://unpkg.com/prismjs@1.30.0/components/prism-core.min.js"></script>
<script src="https://unpkg.com/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>

</html>